{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS'); // @dynamic\n\nclass SmoothScrollManager {\n  constructor(_document, _platform, customDefaultOptions) {\n    this._document = _document;\n    this._platform = _platform; // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n    // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n    // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n    // it cancels the ongoing scroll and starts a new one\n\n    this._onGoingScrolls = new Map();\n    this._defaultOptions = {\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      },\n      ...customDefaultOptions\n    };\n  }\n\n  get _w() {\n    return this._document.defaultView;\n  }\n  /**\r\n   * Timing method\r\n   */\n\n\n  get _now() {\n    return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n  }\n  /**\r\n   * changes scroll position inside an element\r\n   */\n\n\n  _scrollElement(el, x, y) {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n  /**\r\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n   */\n\n\n  _getElement(el, parent) {\n    if (typeof el === 'string') {\n      return (parent || this._document).querySelector(el);\n    }\n\n    return coerceElement(el);\n  }\n  /**\r\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n   */\n\n\n  _initSmoothScroll(el) {\n    if (this._onGoingScrolls.has(el)) {\n      this._onGoingScrolls.get(el).next();\n    }\n\n    return this._onGoingScrolls.set(el, new Subject()).get(el);\n  }\n  /**\r\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n   */\n\n\n  _isFinished(context, destroyed, resolve) {\n    if (context.currentX !== context.x || context.currentY !== context.y) {\n      return true;\n    }\n\n    destroyed.next();\n    resolve();\n    return false;\n  }\n  /**\r\n   * Terminates an ongoing smooth scroll\r\n   */\n\n\n  _interrupted(el, destroyed) {\n    return merge(fromEvent(el, 'wheel', {\n      passive: true,\n      capture: true\n    }), fromEvent(el, 'touchmove', {\n      passive: true,\n      capture: true\n    }), destroyed).pipe(take(1));\n  }\n  /**\r\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n   */\n\n\n  _destroy(el, destroyed) {\n    destroyed.complete();\n\n    this._onGoingScrolls.delete(el);\n  }\n  /**\r\n   * A function called recursively that, given a context, steps through scrolling\r\n   */\n\n\n  _step(context) {\n    return new Observable(subscriber => {\n      let elapsed = (this._now() - context.startTime) / context.duration; // avoid elapsed times higher than one\n\n      elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n      const value = context.easing(elapsed);\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n\n      this._scrollElement(context.scrollable, context.currentX, context.currentY); // Proceed to the step\n\n\n      animationFrameScheduler.schedule(() => subscriber.next(context));\n    });\n  }\n\n  _applyScrollToOptions(el, options) {\n    if (!options.duration) {\n      this._scrollElement(el, options.left, options.top);\n\n      return Promise.resolve();\n    } // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n\n\n    const destroyed = this._initSmoothScroll(el);\n\n    const context = {\n      scrollable: el,\n      startTime: this._now(),\n      startX: el.scrollLeft,\n      startY: el.scrollTop,\n      x: options.left == null ? el.scrollLeft : ~~options.left,\n      y: options.top == null ? el.scrollTop : ~~options.top,\n      duration: options.duration,\n      easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n    };\n    return new Promise(resolve => {\n      // Scroll each step recursively\n      of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n    });\n  }\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param scrollable element\r\n   * @param customOptions specified the offsets to scroll to.\r\n   */\n\n\n  scrollTo(scrollable, customOptions) {\n    if (isPlatformBrowser(this._platform)) {\n      const el = this._getElement(scrollable);\n\n      const isRtl = getComputedStyle(el).direction === 'rtl';\n      const rtlScrollAxisType = getRtlScrollAxisType();\n      const options = { ...this._defaultOptions,\n        ...customOptions,\n        ...{\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n          right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n        }\n      }; // Rewrite the bottom offset as a top offset.\n\n      if (options.bottom != null) {\n        options.top = el.scrollHeight - el.clientHeight - options.bottom;\n      } // Rewrite the right offset as a left offset.\n\n\n      if (isRtl && rtlScrollAxisType !== 0\n      /* RtlScrollAxisType.NORMAL */\n      ) {\n        if (options.left != null) {\n          options.right = el.scrollWidth - el.clientWidth - options.left;\n        }\n\n        if (rtlScrollAxisType === 2\n        /* RtlScrollAxisType.INVERTED */\n        ) {\n          options.left = options.right;\n        } else if (rtlScrollAxisType === 1\n        /* RtlScrollAxisType.NEGATED */\n        ) {\n          options.left = options.right ? -options.right : options.right;\n        }\n      } else {\n        if (options.right != null) {\n          options.left = el.scrollWidth - el.clientWidth - options.right;\n        }\n      }\n\n      return this._applyScrollToOptions(el, options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\r\n   * Scroll to element by reference or selector\r\n   */\n\n\n  scrollToElement(scrollable, target, customOptions = {}) {\n    const scrollableEl = this._getElement(scrollable);\n\n    const targetEl = this._getElement(target, scrollableEl);\n\n    const options = { ...customOptions,\n      ...{\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      }\n    };\n    return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n  }\n\n}\n\nSmoothScrollManager.ɵfac = function SmoothScrollManager_Factory(t) {\n  return new (t || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n};\n\nSmoothScrollManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SmoothScrollManager,\n  factory: SmoothScrollManager.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SMOOTH_SCROLL_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nclass SmoothScroll {\n  constructor(element, smoothScroll) {\n    this.element = element;\n    this.smoothScroll = smoothScroll;\n  }\n\n  scrollTo(options) {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n\n  scrollToElement(target, options) {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n\n}\n\nSmoothScroll.ɵfac = function SmoothScroll_Factory(t) {\n  return new (t || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n};\n\nSmoothScroll.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: SmoothScroll,\n  selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n  exportAs: [\"smoothScroll\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScroll, [{\n    type: Directive,\n    args: [{\n      selector: '[smoothScroll], [smooth-scroll]',\n      exportAs: 'smoothScroll'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: SmoothScrollManager\n    }];\n  }, null);\n})();\n\nclass SmoothScrollModule {}\n\nSmoothScrollModule.ɵfac = function SmoothScrollModule_Factory(t) {\n  return new (t || SmoothScrollModule)();\n};\n\nSmoothScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: SmoothScrollModule\n});\nSmoothScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [SmoothScroll],\n      exports: [SmoothScroll]\n    }]\n  }], null, null);\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Directive","NgModule","isPlatformBrowser","DOCUMENT","coerceElement","getRtlScrollAxisType","Subject","merge","fromEvent","Observable","animationFrameScheduler","of","take","expand","takeWhile","takeUntil","finalize","BezierEasing","SMOOTH_SCROLL_OPTIONS","SmoothScrollManager","constructor","_document","_platform","customDefaultOptions","_onGoingScrolls","Map","_defaultOptions","duration","easing","x1","y1","x2","y2","_w","defaultView","_now","performance","now","bind","Date","_scrollElement","el","x","y","scrollLeft","scrollTop","_getElement","parent","querySelector","_initSmoothScroll","has","get","next","set","_isFinished","context","destroyed","resolve","currentX","currentY","_interrupted","passive","capture","pipe","_destroy","complete","delete","_step","subscriber","elapsed","startTime","value","startX","startY","scrollable","schedule","_applyScrollToOptions","options","left","top","Promise","currContext","subscribe","scrollTo","customOptions","isRtl","getComputedStyle","direction","rtlScrollAxisType","end","start","right","bottom","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollToElement","target","scrollableEl","targetEl","offsetLeft","offsetTop","ɵfac","ɵprov","type","args","providedIn","Document","decorators","undefined","SmoothScroll","element","smoothScroll","ElementRef","ɵdir","selector","exportAs","SmoothScrollModule","ɵmod","ɵinj","declarations","exports"],"sources":["G:/dev/projekte/pokedex-app/node_modules/ngx-scrollbar/fesm2020/ngx-scrollbar-smooth-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\n\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\r\nclass SmoothScrollManager {\r\n    constructor(_document, _platform, customDefaultOptions) {\r\n        this._document = _document;\r\n        this._platform = _platform;\r\n        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\r\n        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n        // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n        // it cancels the ongoing scroll and starts a new one\r\n        this._onGoingScrolls = new Map();\r\n        this._defaultOptions = {\r\n            duration: 468,\r\n            easing: {\r\n                x1: 0.42,\r\n                y1: 0,\r\n                x2: 0.58,\r\n                y2: 1\r\n            },\r\n            ...customDefaultOptions,\r\n        };\r\n    }\r\n    get _w() {\r\n        return this._document.defaultView;\r\n    }\r\n    /**\r\n     * Timing method\r\n     */\r\n    get _now() {\r\n        return this._w.performance && this._w.performance.now\r\n            ? this._w.performance.now.bind(this._w.performance)\r\n            : Date.now;\r\n    }\r\n    /**\r\n     * changes scroll position inside an element\r\n     */\r\n    _scrollElement(el, x, y) {\r\n        el.scrollLeft = x;\r\n        el.scrollTop = y;\r\n    }\r\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\r\n    _getElement(el, parent) {\r\n        if (typeof el === 'string') {\r\n            return (parent || this._document).querySelector(el);\r\n        }\r\n        return coerceElement(el);\r\n    }\r\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\r\n    _initSmoothScroll(el) {\r\n        if (this._onGoingScrolls.has(el)) {\r\n            this._onGoingScrolls.get(el).next();\r\n        }\r\n        return this._onGoingScrolls.set(el, new Subject()).get(el);\r\n    }\r\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\r\n    _isFinished(context, destroyed, resolve) {\r\n        if (context.currentX !== context.x || context.currentY !== context.y) {\r\n            return true;\r\n        }\r\n        destroyed.next();\r\n        resolve();\r\n        return false;\r\n    }\r\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\r\n    _interrupted(el, destroyed) {\r\n        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));\r\n    }\r\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\r\n    _destroy(el, destroyed) {\r\n        destroyed.complete();\r\n        this._onGoingScrolls.delete(el);\r\n    }\r\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\r\n    _step(context) {\r\n        return new Observable((subscriber) => {\r\n            let elapsed = (this._now() - context.startTime) / context.duration;\r\n            // avoid elapsed times higher than one\r\n            elapsed = elapsed > 1 ? 1 : elapsed;\r\n            // apply easing to elapsed time\r\n            const value = context.easing(elapsed);\r\n            context.currentX = context.startX + (context.x - context.startX) * value;\r\n            context.currentY = context.startY + (context.y - context.startY) * value;\r\n            this._scrollElement(context.scrollable, context.currentX, context.currentY);\r\n            // Proceed to the step\r\n            animationFrameScheduler.schedule(() => subscriber.next(context));\r\n        });\r\n    }\r\n    _applyScrollToOptions(el, options) {\r\n        if (!options.duration) {\r\n            this._scrollElement(el, options.left, options.top);\r\n            return Promise.resolve();\r\n        }\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        const destroyed = this._initSmoothScroll(el);\r\n        const context = {\r\n            scrollable: el,\r\n            startTime: this._now(),\r\n            startX: el.scrollLeft,\r\n            startY: el.scrollTop,\r\n            x: options.left == null ? el.scrollLeft : ~~options.left,\r\n            y: options.top == null ? el.scrollTop : ~~options.top,\r\n            duration: options.duration,\r\n            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\r\n        };\r\n        return new Promise(resolve => {\r\n            // Scroll each step recursively\r\n            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\r\n        });\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\r\n    scrollTo(scrollable, customOptions) {\r\n        if (isPlatformBrowser(this._platform)) {\r\n            const el = this._getElement(scrollable);\r\n            const isRtl = getComputedStyle(el).direction === 'rtl';\r\n            const rtlScrollAxisType = getRtlScrollAxisType();\r\n            const options = {\r\n                ...this._defaultOptions,\r\n                ...customOptions,\r\n                ...{\r\n                    // Rewrite start & end offsets as right or left offsets.\r\n                    left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n                    right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n                }\r\n            };\r\n            // Rewrite the bottom offset as a top offset.\r\n            if (options.bottom != null) {\r\n                options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n            }\r\n            // Rewrite the right offset as a left offset.\r\n            if (isRtl && rtlScrollAxisType !== 0 /* RtlScrollAxisType.NORMAL */) {\r\n                if (options.left != null) {\r\n                    options.right = el.scrollWidth - el.clientWidth - options.left;\r\n                }\r\n                if (rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {\r\n                    options.left = options.right;\r\n                }\r\n                else if (rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {\r\n                    options.left = options.right ? -options.right : options.right;\r\n                }\r\n            }\r\n            else {\r\n                if (options.right != null) {\r\n                    options.left = el.scrollWidth - el.clientWidth - options.right;\r\n                }\r\n            }\r\n            return this._applyScrollToOptions(el, options);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\r\n    scrollToElement(scrollable, target, customOptions = {}) {\r\n        const scrollableEl = this._getElement(scrollable);\r\n        const targetEl = this._getElement(target, scrollableEl);\r\n        const options = {\r\n            ...customOptions,\r\n            ...{\r\n                left: targetEl.offsetLeft + (customOptions.left || 0),\r\n                top: targetEl.offsetTop + (customOptions.top || 0)\r\n            }\r\n        };\r\n        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\r\n    }\r\n}\r\nSmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: Document, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Inject,\r\n                    args: [SMOOTH_SCROLL_OPTIONS]\r\n                }] }]; } });\n\nclass SmoothScroll {\r\n    constructor(element, smoothScroll) {\r\n        this.element = element;\r\n        this.smoothScroll = smoothScroll;\r\n    }\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.element, options);\r\n    }\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.element, target, options);\r\n    }\r\n}\r\nSmoothScroll.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScroll, deps: [{ token: i0.ElementRef }, { token: SmoothScrollManager }], target: i0.ɵɵFactoryTarget.Directive });\r\nSmoothScroll.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.1\", type: SmoothScroll, selector: \"[smoothScroll], [smooth-scroll]\", exportAs: [\"smoothScroll\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScroll, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[smoothScroll], [smooth-scroll]',\r\n                    exportAs: 'smoothScroll'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SmoothScrollManager }]; } });\n\nclass SmoothScrollModule {\r\n}\r\nSmoothScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nSmoothScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollModule, declarations: [SmoothScroll], exports: [SmoothScroll] });\r\nSmoothScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollModule });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.1\", ngImport: i0, type: SmoothScrollModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [SmoothScroll],\r\n                    exports: [SmoothScroll]\r\n                }]\r\n        }] });\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}